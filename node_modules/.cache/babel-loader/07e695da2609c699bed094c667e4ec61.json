{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _LazyPoint = require('./LazyPoint');\n\nvar _LazyPoint2 = _interopRequireDefault(_LazyPoint);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar RADIUS_DEFAULT = 30;\n\nvar LazyBrush = function () {\n  /**\n   * constructor\n   *\n   * @param {object} settings\n   * @param {number} settings.radius The radius for the lazy area\n   * @param {boolean} settings.enabled\n   */\n  function LazyBrush() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$radius = _ref.radius,\n        radius = _ref$radius === undefined ? RADIUS_DEFAULT : _ref$radius,\n        _ref$enabled = _ref.enabled,\n        enabled = _ref$enabled === undefined ? true : _ref$enabled,\n        _ref$initialPoint = _ref.initialPoint,\n        initialPoint = _ref$initialPoint === undefined ? {\n      x: 0,\n      y: 0\n    } : _ref$initialPoint;\n\n    _classCallCheck(this, LazyBrush);\n\n    this.radius = radius;\n    this._isEnabled = enabled;\n    this.pointer = new _LazyPoint2.default(initialPoint.x, initialPoint.y);\n    this.brush = new _LazyPoint2.default(initialPoint.x, initialPoint.y);\n    this.angle = 0;\n    this.distance = 0;\n    this._hasMoved = false;\n  }\n  /**\n   * Enable lazy brush calculations.\n   *\n   */\n\n\n  _createClass(LazyBrush, [{\n    key: 'enable',\n    value: function enable() {\n      this._isEnabled = true;\n    }\n    /**\n     * Disable lazy brush calculations.\n     *\n     */\n\n  }, {\n    key: 'disable',\n    value: function disable() {\n      this._isEnabled = false;\n    }\n    /**\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'isEnabled',\n    value: function isEnabled() {\n      return this._isEnabled;\n    }\n    /**\n     * Update the radius\n     *\n     * @param {number} radius\n     */\n\n  }, {\n    key: 'setRadius',\n    value: function setRadius(radius) {\n      this.radius = radius;\n    }\n    /**\n     * Return the current radius\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: 'getRadius',\n    value: function getRadius() {\n      return this.radius;\n    }\n    /**\n     * Return the brush coordinates as a simple object\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: 'getBrushCoordinates',\n    value: function getBrushCoordinates() {\n      return this.brush.toObject();\n    }\n    /**\n     * Return the pointer coordinates as a simple object\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: 'getPointerCoordinates',\n    value: function getPointerCoordinates() {\n      return this.pointer.toObject();\n    }\n    /**\n     * Return the brush as a LazyPoint\n     *\n     * @returns {LazyPoint}\n     */\n\n  }, {\n    key: 'getBrush',\n    value: function getBrush() {\n      return this.brush;\n    }\n    /**\n     * Return the pointer as a LazyPoint\n     *\n     * @returns {LazyPoint}\n     */\n\n  }, {\n    key: 'getPointer',\n    value: function getPointer() {\n      return this.pointer;\n    }\n    /**\n     * Return the angle between pointer and brush\n     *\n     * @returns {number} Angle in radians\n     */\n\n  }, {\n    key: 'getAngle',\n    value: function getAngle() {\n      return this.angle;\n    }\n    /**\n     * Return the distance between pointer and brush\n     *\n     * @returns {number} Distance in pixels\n     */\n\n  }, {\n    key: 'getDistance',\n    value: function getDistance() {\n      return this.distance;\n    }\n    /**\n     * Return if the previous update has moved the brush.\n     *\n     * @returns {boolean} Whether the brush moved previously.\n     */\n\n  }, {\n    key: 'brushHasMoved',\n    value: function brushHasMoved() {\n      return this._hasMoved;\n    }\n    /**\n     * Updates the pointer point and calculates the new brush point.\n     *\n     * @param {Point} newPointerPoint\n     * @param {Object} options\n     * @param {Boolean} options.both Force update pointer and brush\n     * @returns {Boolean} Whether any of the two points changed\n     */\n\n  }, {\n    key: 'update',\n    value: function update(newPointerPoint) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$both = _ref2.both,\n          both = _ref2$both === undefined ? false : _ref2$both;\n\n      this._hasMoved = false;\n\n      if (this.pointer.equalsTo(newPointerPoint) && !both) {\n        return false;\n      }\n\n      this.pointer.update(newPointerPoint);\n\n      if (both) {\n        this._hasMoved = true;\n        this.brush.update(newPointerPoint);\n        return true;\n      }\n\n      if (this._isEnabled) {\n        this.distance = this.pointer.getDistanceTo(this.brush);\n        this.angle = this.pointer.getAngleTo(this.brush);\n\n        if (this.distance > this.radius) {\n          this.brush.moveByAngle(this.angle, this.distance - this.radius);\n          this._hasMoved = true;\n        }\n      } else {\n        this.distance = 0;\n        this.angle = 0;\n        this.brush.update(newPointerPoint);\n        this._hasMoved = true;\n      }\n\n      return true;\n    }\n  }]);\n\n  return LazyBrush;\n}();\n\nexports.default = LazyBrush;","map":{"version":3,"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","_LazyPoint","require","_LazyPoint2","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","TypeError","RADIUS_DEFAULT","LazyBrush","_ref","arguments","undefined","_ref$radius","radius","_ref$enabled","enabled","_ref$initialPoint","initialPoint","x","y","_isEnabled","pointer","brush","angle","distance","_hasMoved","enable","disable","isEnabled","setRadius","getRadius","getBrushCoordinates","toObject","getPointerCoordinates","getBrush","getPointer","getAngle","getDistance","brushHasMoved","update","newPointerPoint","_ref2","_ref2$both","both","equalsTo","getDistanceTo","getAngleTo","moveByAngle"],"sources":["/Users/vladikumpan/draw-guess/node_modules/lazy-brush/lib/LazyBrush.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _LazyPoint = require('./LazyPoint');\n\nvar _LazyPoint2 = _interopRequireDefault(_LazyPoint);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar RADIUS_DEFAULT = 30;\n\nvar LazyBrush = function () {\n  /**\n   * constructor\n   *\n   * @param {object} settings\n   * @param {number} settings.radius The radius for the lazy area\n   * @param {boolean} settings.enabled\n   */\n  function LazyBrush() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$radius = _ref.radius,\n        radius = _ref$radius === undefined ? RADIUS_DEFAULT : _ref$radius,\n        _ref$enabled = _ref.enabled,\n        enabled = _ref$enabled === undefined ? true : _ref$enabled,\n        _ref$initialPoint = _ref.initialPoint,\n        initialPoint = _ref$initialPoint === undefined ? { x: 0, y: 0 } : _ref$initialPoint;\n\n    _classCallCheck(this, LazyBrush);\n\n    this.radius = radius;\n    this._isEnabled = enabled;\n\n    this.pointer = new _LazyPoint2.default(initialPoint.x, initialPoint.y);\n    this.brush = new _LazyPoint2.default(initialPoint.x, initialPoint.y);\n\n    this.angle = 0;\n    this.distance = 0;\n    this._hasMoved = false;\n  }\n\n  /**\n   * Enable lazy brush calculations.\n   *\n   */\n\n\n  _createClass(LazyBrush, [{\n    key: 'enable',\n    value: function enable() {\n      this._isEnabled = true;\n    }\n\n    /**\n     * Disable lazy brush calculations.\n     *\n     */\n\n  }, {\n    key: 'disable',\n    value: function disable() {\n      this._isEnabled = false;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'isEnabled',\n    value: function isEnabled() {\n      return this._isEnabled;\n    }\n\n    /**\n     * Update the radius\n     *\n     * @param {number} radius\n     */\n\n  }, {\n    key: 'setRadius',\n    value: function setRadius(radius) {\n      this.radius = radius;\n    }\n\n    /**\n     * Return the current radius\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: 'getRadius',\n    value: function getRadius() {\n      return this.radius;\n    }\n\n    /**\n     * Return the brush coordinates as a simple object\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: 'getBrushCoordinates',\n    value: function getBrushCoordinates() {\n      return this.brush.toObject();\n    }\n\n    /**\n     * Return the pointer coordinates as a simple object\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: 'getPointerCoordinates',\n    value: function getPointerCoordinates() {\n      return this.pointer.toObject();\n    }\n\n    /**\n     * Return the brush as a LazyPoint\n     *\n     * @returns {LazyPoint}\n     */\n\n  }, {\n    key: 'getBrush',\n    value: function getBrush() {\n      return this.brush;\n    }\n\n    /**\n     * Return the pointer as a LazyPoint\n     *\n     * @returns {LazyPoint}\n     */\n\n  }, {\n    key: 'getPointer',\n    value: function getPointer() {\n      return this.pointer;\n    }\n\n    /**\n     * Return the angle between pointer and brush\n     *\n     * @returns {number} Angle in radians\n     */\n\n  }, {\n    key: 'getAngle',\n    value: function getAngle() {\n      return this.angle;\n    }\n\n    /**\n     * Return the distance between pointer and brush\n     *\n     * @returns {number} Distance in pixels\n     */\n\n  }, {\n    key: 'getDistance',\n    value: function getDistance() {\n      return this.distance;\n    }\n\n    /**\n     * Return if the previous update has moved the brush.\n     *\n     * @returns {boolean} Whether the brush moved previously.\n     */\n\n  }, {\n    key: 'brushHasMoved',\n    value: function brushHasMoved() {\n      return this._hasMoved;\n    }\n\n    /**\n     * Updates the pointer point and calculates the new brush point.\n     *\n     * @param {Point} newPointerPoint\n     * @param {Object} options\n     * @param {Boolean} options.both Force update pointer and brush\n     * @returns {Boolean} Whether any of the two points changed\n     */\n\n  }, {\n    key: 'update',\n    value: function update(newPointerPoint) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$both = _ref2.both,\n          both = _ref2$both === undefined ? false : _ref2$both;\n\n      this._hasMoved = false;\n      if (this.pointer.equalsTo(newPointerPoint) && !both) {\n        return false;\n      }\n\n      this.pointer.update(newPointerPoint);\n\n      if (both) {\n        this._hasMoved = true;\n        this.brush.update(newPointerPoint);\n        return true;\n      }\n\n      if (this._isEnabled) {\n        this.distance = this.pointer.getDistanceTo(this.brush);\n        this.angle = this.pointer.getAngleTo(this.brush);\n\n        if (this.distance > this.radius) {\n          this.brush.moveByAngle(this.angle, this.distance - this.radius);\n          this._hasMoved = true;\n        }\n      } else {\n        this.distance = 0;\n        this.angle = 0;\n        this.brush.update(newPointerPoint);\n        this._hasMoved = true;\n      }\n\n      return true;\n    }\n  }]);\n\n  return LazyBrush;\n}();\n\nexports.default = LazyBrush;"],"mappings":"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"},"metadata":{},"sourceType":"script"}